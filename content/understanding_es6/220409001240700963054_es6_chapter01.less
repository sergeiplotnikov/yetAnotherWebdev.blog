yet_another_webdev(blog)           2022-04-09           yet_another_webdev(blog)



PPRROOJJEECCTT
       Understanding ECMAScript 6

PPOOSSTT
       Chapter 01 - Block Bindings

DDEESSCCRRIIPPTTIIOONN
       Introduces  the 'let' and 'const' variable declarations and compares them
       to 'var' in different contexts.




vvaarr DDeeccllaarraattiioonn aanndd HHooiissttiinngg::
       Variable declaration using var are treated as if they're at  the  top  of
       the  function  or  in  the  global scope (if outside a function). This is
       called hoisting. Variable declaration is  hoisted  to  the  top  and  the
       initialization remains in the same spot.

BBlloocckk--LLeevveell DDeeccllaarraattiioonnss::
       Block-level declararion declare bindings  that are inaccessible outside a
       given block scope. 'Block scope', also called 'lexical scope' is  created
       in funcions and blocks indicated by { and }.

   lleett DDeeccllaarraattiioonnss::
       With  syntax  similar  to  'var' they are not hoisted to the top, and are
       accessible only inside the scope and after declaration.

   NNoo RReeddeeccllaarraattiioonn::
       If and identifier was already defined in a scope, a repeaded  declaration
       in  the same scope will throw an error. If a variable declararion uses an
       identifier that is already used in an  outer  scope,  no  error  will  be
       throws.  The  inner  scope variable 'shadows' the other variale making it
       inaccessible in the inner scope.

[96m$ cat > shadow.js[m
[96mvar count = 30;[m
[96mif (true) {[m
[96m     let count = 50;[m
[96m     console.log(count);[m
[96m}[m
[96m^C[m
[96m$ node shadow.js[m
[96m50[m

   ccoonnsstt DDeeccllaarraattiioonn::
       When defining a variable using 'const',  the  variable  is  considered  a
       constant  in  the sense that the value cannot be change once set. This is
       why initialization must alwasy occur at declaration, otherwise  an  error
       will be thrown.

   CCoonnssttaanntt vvss.. lleett DDeeccllaarraattiioonnss::
       Both  declarations  are  accessible only the the scope they were declared
       in.  Neither is hoisted. Both will shadow variables with  identical  name
       from  outer  scope.  Constant variables, unlike let, cannot be assigned a
       new value, such an attempt will throw an error even in non-strict mode.

   OObbjjeecctt DDeeccllaarraattiioonnss wwiitthh ccoonnsstt::
       A constant declaration prevents modification of the binding, not  of  the
       value.   So  a  const  declaration  of  an  object  will  not  prevent  a
       modification of the object.

[96m$ cat > object.js[m
[96mconst person = {[m
[96m     name: "Nicholas",[m
[96m};[m
[96mperson.name = "Greg";[m
[96mconsole.log(person);[m
[96mperson = {[m
[96m     name: "Greg",[m
[96m};[m
[96m^C[m
[96m$ node object.js[m
[96m{ name: 'Greg' }[m
[96m/home/sergei/yetanotherwebdev.blog/temp/object.js:6[m
[96mperson = {[m
[96m       ^[m
[96m[m
[96mTypeError: Assignment to constant variable.[m
[96m    at Object.<anonymous> (/home/sergei/yetanotherwebdev.blog/temp/object.js:6:8)[m
[96m    at Module._compile (internal/modules/cjs/loader.js:778:30)[m
[96m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)[m
[96m    at Module.load (internal/modules/cjs/loader.js:653:32)[m
[96m    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)[m
[96m    at Function.Module._load (internal/modules/cjs/loader.js:585:3)[m
[96m    at Function.Module.runMain (internal/modules/cjs/loader.js:831:12)[m
[96m    at startup (internal/bootstrap/node.js:283:19)[m
[96m    at bootstrapNodeJSCore (internal/bootstrap/node.js:623:3)[m

   TThhee TTeemmppoorraall DDeeaadd ZZoonnee::
       A variable declaration with either let or const cannot be accessed  until
       after  the declaration. Attempting to do so  resulte in a refernce error.
       TDZ is never named explicitly in the ECMAScript  specification,  but  the
       term  is  often  used  to  describe  why  let  and const bindings are not
       accessible before their declaration (unlike var).

       TDZ is different from a case where the identifier used was  simply  never
       defined.   A  variable  is in the TDZ only in the scope it is defined but
       before the definition. The following two examples demonstare this:

[96m$ cat > tdz.js[m
[96mif (true) {[m
[96m     console.log(typeof value);[m
[96m     let value = "blue";[m
[96m}[m
[96m^C[m
[96m$ node tdz.js[m
[96m/home/sergei/yetanotherwebdev.blog/temp/tdz.js:2[m
[96m     console.log(typeof value);[m
[96m             ^[m
[96m[m
[96mReferenceError: value is not defined[m
[96m    at Object.<anonymous> (/home/sergei/yetanotherwebdev.blog/temp/tdz.js:2:10)[m
[96m    at Module._compile (internal/modules/cjs/loader.js:778:30)[m
[96m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)[m
[96m    at Module.load (internal/modules/cjs/loader.js:653:32)[m
[96m    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)[m
[96m    at Function.Module._load (internal/modules/cjs/loader.js:585:3)[m
[96m    at Function.Module.runMain (internal/modules/cjs/loader.js:831:12)[m
[96m    at startup (internal/bootstrap/node.js:283:19)[m
[96m    at bootstrapNodeJSCore (internal/bootstrap/node.js:623:3)[m


       The typeof function tried to access the 'value' variable in the scope  it
       was defined in but before the definition, thus in the TDZ.

[96m$ cat > noTdz.js[m
[96mconsole.log(typeof value);[m
[96mif (true) {[m
[96m     let value = "blue";[m
[96m}[m
[96m^C[m
[96m$ node noTdz.js[m
[96mundefined[m


       The  'value' is not defined in the scope of typeof, so there is no attemp
       to access a variable inside the TDZ and no error is throws.

BBlloocckk BBiinnddiinnggss iinn LLooooppss ::
       If a for-loop index was defined as var it will be available  outside  the
       loops block.

[96m$ cat > varForLoop.js[m
[96mfor ( var i = 0; i < 3; i++) {[m
[96m     console.log(i);[m
[96m}[m
[96mconsole.log(i);[m
[96m^C[m
[96m$ node varForLoop.js[m
[96m0[m
[96m1[m
[96m2[m
[96m3[m

[96m$ cat > letForLoop.js[m
[96mfor ( let i = 0; i < 3; i++) {[m
[96m     console.log(i);[m
[96m}[m
[96mconsole.log(typeof i);[m
[96m^C[m
[96m$ node letForLoop.js[m
[96m0[m
[96m1[m
[96m2[m
[96mundefined[m


       \'i\'  exists only within the for loop scope. An attempt to read it would
       throw an error.

FFuunnccttiioonnss iinn LLooooppss::
       When var is used as a loop index it behaves as single  'global'  variable
       and creates the following issue:

[96m$ cat > varForLoopFuncs.js[m
[96mvar funcs = [];[m
[96m[m
[96mfor ( var i = 0; i < 3; i++) {[m
[96m     funcs.push(function() {[m
[96m          console.log(i);[m
[96m     });[m
[96m}[m
[96m[m
[96mfuncs.forEach(function(func) {[m
[96m     func();[m
[96m});[m
[96m^C[m
[96m$ node varForLoopFuncs.js[m
[96m3[m
[96m3[m
[96m3[m


       Since  by  the  time  the loop is done 'i' equals 3 and all the functions
       point to the same 'i', they all print 3.

       This  issue  can  be  solved  by  using  'immediately  invoked   function
       expressions'  (IIFEs).  This  method  creates a local copy of i, with the
       value of 'i'  at  the  time  of  invokation,  for  each  of  the  created
       functions.

[96m$ cat > varForLoopIIFE.js[m
[96mvar funcs = [];[m
[96m[m
[96mfor ( var i = 0; i < 3; i++) {[m
[96m     funcs.push((function(value) {[m
[96m          return function() {[m
[96m               console.log(value);[m
[96m          }[m
[96m     }(i)));[m
[96m}[m
[96m[m
[96mfuncs.forEach(function(func) {[m
[96m     func();[m
[96m});[m
[96m^C[m
[96m$ node varForLoopIIFE.js[m
[96m0[m
[96m1[m
[96m2[m


       In  the  exmaple above, for each iteration of the loop, the current value
       of 'i' is stored as a local 'value' variable.

   lleett DDeeccllaarraattiioonnss iinn LLooooppss
       Declaring the for loop with 'let' allows you the get the same  result  as
       the last example, but without using IIFEs:

[96m$ cat > letForLoop.js[m
[96mvar funcs = [];[m
[96m[m
[96mfor ( let i = 0; i < 3; i++) {[m
[96m     funcs.push(function() {[m
[96m          console.log(i);[m
[96m     });[m
[96m}[m
[96m[m
[96mfuncs.forEach(function(func) {[m
[96m     func();[m
[96m})[m
[96m^C[m
[96m$ node letForLoop.js[m
[96m0[m
[96m1[m
[96m2[m


       The  let  declaration  causes  a  new  variable  to  be created each loop
       iteration. The same is true for 'for-in' and 'for-of' loops.

              [page 10] "It's important to understand that the behavior  of  let
              declarations  in  loop  is  a  specially  defined  behavior in the
              specification and is not necessarily related to  the  non-hoisting
              characteristics  of let. In fact, early implementations of let did
              not exhibit this behavior, because  it  was  added  later  in  the
              process." [page 10]

   ccoonnsstt DDeeccllaarraattiioonn iinn LLooooppss::
       Using  a  const  index in a 'simple' for loop works fine until you try to
       update the value of the index:

[96m$ cat > constForLoop.js[m
[96mfor ( const i = 0; i < 3; i++) {[m
[96m     console.log(i);[m
[96m}[m
[96m^C[m
[96m$ node constForLoop.js[m
[96m0[m
[96m/home/sergei/yetanotherwebdev.blog/temp/constForLoop_01.js:1[m
[96mfor ( const i = 0; i < 3; i++) {[m
[96m                           ^[m
[96m[m
[96mTypeError: Assignment to constant variable.[m
[96m    at Object.<anonymous> (/home/sergei/yetanotherwebdev.blog/temp/constForLoop_01.js:1:28)[m
[96m    at Module._compile (internal/modules/cjs/loader.js:778:30)[m
[96m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)[m
[96m    at Module.load (internal/modules/cjs/loader.js:653:32)[m
[96m    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)[m
[96m    at Function.Module._load (internal/modules/cjs/loader.js:585:3)[m
[96m    at Function.Module.runMain (internal/modules/cjs/loader.js:831:12)[m
[96m    at startup (internal/bootstrap/node.js:283:19)[m
[96m    at bootstrapNodeJSCore (internal/bootstrap/node.js:623:3)[m


       The first iteration completed successfully and then an error  was  thrown
       when  the  increment  operator attempted to update a 'constant' varialbe.
       For 'for-in' and cause problems. This is because on each loop iteration a
       new binding is created.

GGlloobbaall BBlloocckk BBiinnddiinngg
       When  using  var  declaratin in the global scope, it craetes a new global
       variable which is a property on the global object ('window'  in  browser,
       'globlal' in Node). This means you can accidentally overwrite an existing
       globla property.

[96m$ cat > globalVar.js[m
[96mvar xyz = 'some text';[m
[96mconsole.log('xyz' in global);[m
[96m^C[m
[96m$ node globalVar.js[m
[96mfalse[m


       While running  the  script  above  does  not  demonstarte  the  described
       behavior,  because  you get false, running the same code inside Node REPL
       will return TRUE.  The reason for this is  the  fact  that  code  from  a
       script runs inside a module while REPL runs 'global'.

        Based on: https://stackoverflow.com/questions/20861049/this-different-
        between-repl-and-script


       Declaring a variable in the global scope, that shares a name with a prop‐
       erty  of a global object (window or global) will not overwrite this prop‐
       erty but will shadow it.

[96m$ echo "console.log(RegExp === global.RegExp)" | node[m
[96mtrue[m
[96m$ cat > globalShadowing.js[m
[96mlet RegExp = '123';[m
[96mconsole.log(RegExp === global.RegExp);[m
[96mconsole.log(RegExp);[m
[96m^C[m
[96m$ node globalShadowing.js[m
[96mfalse[m
[96m123[m


              "You might still want to use var in the global scope if  you  have
              code taht should be available from the globla object. This is most
              common in a browser when you want to access code accross frames or
              windows." [page 12]


toolsV1                                                 yet_another_webdev(blog)
