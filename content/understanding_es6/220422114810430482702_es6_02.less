yet_another_webdev(blog)           2022-04-22           yet_another_webdev(blog)



PPRROOJJEECCTT
       Understanding ECMAScript 6

PPOOSSTT
       Chapter 02 - String and Regular Expressions

DDEESSCCRRIIPPTTIIOONN
       Chapter 2 introduces new support for Unicode and regular expressions, and
       the new "Template Literals" feature.




BBeetttteerr UUnniiccooddee SSuuppppoorrtt
       Bedore ES6, JS assumed that each 16-bit sequence, called a  'code  unit',
       represented  a single character. All string functions and properties were
       base on these 16-bit code units.

   UUTTFF--1166 CCooddee PPooiinnttss
       The Unicode standard assigns a unique identifier for every  character  in
       the  world.  These identifiers are called 'code points'. They are numbers
       starting at 0. For UTF-16 the code points can consist  of  multiple  code
       units. The first 2^16 code points are represented by a single 16-bit code
       unit. This range is called  the  Basic  Multilingual  Plane  (BMP).  Code
       points  beyond  this  range  belong to one of the 'supplementary planes'.
       Code points there are represented in UTF-16 using  'surrogate  pairs'  in
       which  a  single code point is represented by two 16-bit code units. That
       means that in a string a character can be represeted by one or two 16-bit
       code units.

[96m$ cat > test1.js[m
[96mlet text = "" + String.fromCodePoint(134071);[m
[96mconsole.log(text);[m
[96mconsole.log(text.length);[m
[96mconsole.log(/^.$/.test(text));[m
[96mconsole.log(text.charAt(0));[m
[96mconsole.log(text.charAt(1));[m
[96mconsole.log(text.charCodeAt(0));[m
[96mconsole.log(text.charCodeAt(1));[m
[96m^C[m
[96m$ node test1.js[m
[96mð ®·[m
[96m2[m
[96mfalse[m
[96mï¿½[m
[96mï¿½[m
[96m55362[m
[96m57271[m


       The  134071  code  point  is  represented  by  a  surrogate painr, so the
       functions in this example treat the string as having two characters.  ES6
       addresses  these  issues  by  standardizing  sting  operations to support
       surrogate pairs.

   TThhee ccooddeePPooiinnttAAtt(()) MMeetthhoodd
       A method added in ES6 that retreives the Unicode code point that maps  to
       a  given  position  in  a  string.  It  accepts  code unit positions, not
       character positions.

[96m$ cat > test2.js[m
[96mlet text = "a" + String.fromCodePoint(134071);[m
[96mconsole.log(text);[m
[96m[m
[96mconsole.log(text.charCodeAt(0));[m
[96mconsole.log(text.charCodeAt(1));[m
[96mconsole.log(text.charCodeAt(2));[m
[96m[m
[96mconsole.log(text.codePointAt(0));[m
[96mconsole.log(text.codePointAt(1));[m
[96mconsole.log(text.codePointAt(2));[m
[96m[m
[96mconsole.log(text.length);[m
[96m^C[m
[96m$ node test2.js[m
[96mað ®·[m
[96m97[m
[96m55362[m
[96m57271[m
[96m97[m
[96m134071[m
[96m57271[m
[96m3[m


       codePointAt() method returns the same value  as  charCodeAt()  unless  it
       operates on non-BMP characters.

   TThhee SSttrriinngg..ffrroommCCooddeePPooiinntt(()) MMeetthhoodd
       This function produces a single character string from a given code point.

   TThhee nnoorrmmaalliizzee(()) MMeetthhoodd
       Different  characters  can  be considered equivalent for sorting or other
       comparison  based  operations.  There  are  two  ways  to  define   these
       relationships:

       â€¢      "Canonical  equivalence"  means  that two sequences of code points
              are considered interchangeable in all aspects.

       â€¢      "Compatibility" means that two compatible sequences of code points
              different but can be used interchangeable in certain situations.

       Due  to  these  relationships, two strings representing fundumentally the
       same text can contain different code point sequences.  For  example,  the
       'Ã¦'  character  adn  the  'ae'  string  can  be  used interchangeably but
       strictly not equivalent unless normalized.

       EC6 supports Unicode normalization forms by giving string  a  normalize()
       method. It optionally accepts a single string parametere to indicate what
       normalization for should be applied:

       â€¢      Normalization Form Canonical Composition ("NFC"), the default

       â€¢      Normalization Form Canonical Decomposition ("NFD")

       â€¢      Normalization Form Compatibility Composition ("NFKC")

       â€¢      Normalization Form Compatibility Decomposition ("NFKD")

       Before comparing strings, both strings must be  normalized  to  the  same
       form.

TThhee RReegguullaarr EExxpprreessssiioonn uu FFllaagg
   TThhee uu FFllaagg iinn AAccttiioonn
       When  regural  expression  has the 'u' flag set, it switches from working
       with code units to working with characters. In this case, surrogate pairs
       will not be treated as a separate character.

[96m$ cat > test3.js[m
[96mlet text = "" + String.fromCodePoint(134071);[m
[96mconsole.log(text);[m
[96mconsole.log(text.length);[m
[96mconsole.log(/^.$/.test(text));[m
[96mconsole.log(/^.$/u.test(text));[m
[96m^C[m
[96m$ node test3.js[m
[96mð ®·[m
[96m2[m
[96mfalse[m
[96mtrue[m

   CCoouunnttiinngg CCooddee PPooiinnttss
       Under  ES6, the 'length' property still returns the number of code units.
       Using the regex 'u' flag one can write a code ponint counting function as
       follows:

[96m$ cat > codePointCounter.js[m
[96mfunction codePointLength(text) {[m
[96m     let result = text.match(/[\s\S]/gu);[m
[96m     return result ? result.length : 0;[m
[96m}[m
[96m[m
[96mconsole.log(codePointLength("abc"));[m
[96mconsole.log(codePointLength(String.fromCodePoint(134071) + "bc"));[m
[96m^C[m
[96m$ node codePointCounter.js[m
[96m3[m
[96m3[m


              [page  19]  "Although  this  appreach  works,  it's not very fast,
              especially when applied to long strings.  You  can  use  a  string
              iterator  (discussed  in  Chapter  8)  as well. In general, try to
              minimize counting code points whenever possible." [page 19]

OOtthheerr SSttrriinngg CChhaannggeess
   MMeetthhooddss ffoorr IIddeennttiiffyyiinngg SSuubbssttrriinnggss
       ES6  includes  additional  methods  for  identifying  substrings  besides
       indexOf():

       â€¢      includes():  returns  TRUE  is  the  given  text is found anywhere
              within the string.

       â€¢      startsWith(): returns TRUE if the  given  text  is  found  at  the
              beginning of the string.

       â€¢      endsWith():  returns TRUE if the given text is found at the end of
              the string.

       Each method accepts two arguments: the text to search for and an optional
       index from which to start the search.

              [page  20]  "The  startsWith(), endsWith(), and includes() methods
              will throw an error if you pass a regular expression instead of  a
              string. In contrast, indexOf() and lastIndexOf() convert a regular
              expression argument  into  a  string  and  then  search  for  that
              string." [page 20]

   TThhee rreeppeeaatt(()) MMeetthhoodd
       This method returns a string containing n copies of the given string. Its
       useful in code formating for creating indentation levels:

[96m$ cat > repeat.js[m
[96mconsole.log("abc ".repeat(3));[m
[96m^C[m
[96m$ node repeat.js[m
[96mabc abc abc[m


OOtthheerr RReegguullaarr EExxpprreessssiioonn CChhaannggeess
   TThhee RReegguullaarr EExxpprreessssiioonn yy ffllaagg
       The y flag affects a regular expression search's sticky property, and  it
       tells  the  search to start matching characters in a string at a position
       specified by the regular expressions 'lastIndex' property. If there is no
       match at that location, the regular expression stops matching:

[96m$ cat > stickyRegex.js[m
[96mlet text = "hello1 hello2 hello3",[m
[96m    pattern = /hello\d\s?/,[m
[96m    result = pattern.exec(text),[m
[96m    globalPattern = /hello\d\s?/g,[m
[96m    globalResult = globalPattern.exec(text),[m
[96m    stickyPattern = /hello\d\s?/y,[m
[96m    stickyResult = stickyPattern.exec(text);[m
[96m[m
[96mconsole.log(result[0]);[m
[96mconsole.log(globalResult[0]);[m
[96mconsole.log(stickyResult[0], '\n');[m
[96m[m
[96mpattern.lastIndex = 1;[m
[96mglobalPattern.lastIndex = 1;[m
[96mstickyPattern.lastIndex = 1;[m
[96m[m
[96mresult = pattern.exec(text);[m
[96mglobalResult = globalPattern.exec(text);[m
[96mstickyResult = stickyPattern.exec(text);[m
[96m[m
[96mconsole.log(result[0]);[m
[96mconsole.log(globalResult[0]);[m
[96mconsole.log("" + (null === stickyResult), stickyPattern.lastIndex, '\n');[m
[96m[m
[96mstickyResult = stickyPattern.exec(text);[m
[96mconsole.log(stickyResult[0], stickyPattern.lastIndex);[m
[96mstickyResult = stickyPattern.exec(text);[m
[96mconsole.log(stickyResult[0], stickyPattern.lastIndex);[m
[96mstickyResult = stickyPattern.exec(text);[m
[96mconsole.log(stickyResult[0], stickyPattern.lastIndex);[m
[96m^C[m
[96m$ node stickyRegex.js[m
[96mhello1[m
[96mhello1[m
[96mhello1[m
[96m[m
[96mhello1[m
[96mhello2[m
[96mtrue 0[m
[96m[m
[96mhello1  7[m
[96mhello2  14[m
[96mhello3 20[m


       Analisys of the example above:

       11..     All 3 patterns found the matching pattern 'hello1 '.

       22..     "lastIndex" of all 3 patterns was set to 1.

       33..     The  no-flags pattern ignored the 'lastIndex' property and started
              matching from the begining  of  the  string.  The  global  pattern
              matched  to  'hello2 ' as expected. Sticky pattern does not behave
              like the global  one  and  tries  to  match  at  the  position  of
              'lastIndex'.

       44..     Because  the  'lastIndex' of the sticky is 1. Sticky pattern fails
              to match and 'stickyResult' is set to NULL while  sticky  patterns
              'lastIndex' is set to 0.

       55..     Since  'lastIndex'  of the sticky pattern is set to 0, the pattern
              matches the text successfully 3 times as expected.

       There are two subtle details about the 'y' flag:

       â€¢      The 'lastIndex' property is honored only when the  methods  called
              exist  on  the  regular expression object, like exec() and test().
              Passing the 'y' flag to a string  method  like  match()  will  not
              result in sticky behavior.

       â€¢      When  the sticky regular expression use the '^' character to match
              the start of a string, they only  match  from  the  start  of  the
              string  (or the start of the line in multiline mode). Althouhg the
              'lastIndex' is 0, the '^' makes a sticky  regular  expression  the
              same as a non-sticky one. If the 'lastIndex' doesn't correspond to
              the beginning of  the  string  in  the  single-line  mode  or  the
              beginning  of  a  line  in  a  multiline  mode, the sticky regular
              expression will never match.

   DDuupplliiccaattee RReegguullaarr EExxpprreessssiioonnss
       In ES5 the following code duplicates a regular expression:

[96m$ cat > es5regexDuplicateOk.js[m
[96mvar re1 = /ab/i,[m
[96m    re2 = new RegExp(re1);[m
[96m^C[m
[96m$ node es5regexDuplicateOk.js[m
[96m$[m


       The following code is legal in ES6 but not in ES5:

[96m$ cat > regexDuplicate.js[m
[96mvar re1 = /ab/i,[m
[96m    re2 = new RegExp(re1, "g");[m
[96m[m
[96mconsole.log(re1.toString());[m
[96mconsole.log(re2.toString());[m
[96m^C[m
[96m$ node regexDuplicate.js[m
[96m/ab/i[m
[96m/ab/g[m


   TTnnee ffllaaggss PPrrooppeerrttyy
       ES6 allows you to read the flags of a regular expression using a getter:

[96m$ cat > flags.js[m
[96mvar re = /ab/g;[m
[96mconsole.log(re.source);[m
[96mconsole.log(re.flags);[m
[96m^C[m
[96m$ node flags.js[m
[96mab[m
[96mg[m


TTeemmppllaattee LLiitteerraallss
       ES6 brings template literals to provide the following  features  that  JS
       lacked

       â€¢      Multiline strings - a formal concept of multiline strings.

       â€¢      Basic  string  formatting - the ability to substitute parts of the
              string for values contained in variables.

       â€¢      HTML escaping - the ability to transform a string so it is safe to
              insert into HTML.

   BBaassiicc SSyynnttaaxx
       The  simplest  use  of string literals is to create string using backtics
       instead single or double quotes:

[96m$ cat > string.js[m
[96mlet text = `Hello world!`;[m
[96mconsole.log(text);[m
[96mconsole.log(typeof text);[m
[96mconsole.log(text.length);[m
[96m^C[m
[96m$ node string.js[m
[96mHello world![m
[96mstring[m
[96m12[m


       To include backtick character inside  string  literal,  escape  it  using
       backslash. There is no need to escape single or double quotes.

   MMuullttiilliinnee SSttrriinnggss
       When  using  single  or  double  quotes  for  strings, the string must be
       contained on a single line.

   PPrree--EESS66 WWoorrkkaarroouunndd
[96m$ cat > multilineES5.js[m
[96mlet text1 = "hello \[m
[96mworld";[m
[96m[m
[96mlet text2 = "1st line \n\[m
[96m2nd line";[m
[96m[m
[96mconsole.log(text1);[m
[96mconsole.log(text2);[m
[96m^C[m
[96m$ node multilineES5.js[m
[96mhello world[m
[96m1st line[m
[96m2nd line[m


       The second string in example above SHOULD print out 2 lines on all  major
       JS  engines. However the behavior is defined as a bug and many developers
       recomend avoding it. Anoter pre-ES6 solution is  to  join  and  array  of
       single line strings:

[96m$ cat > multilineES5_array.js[m
[96mlet arr = [[m
[96m     "1st line",[m
[96m     "2nd line",[m
[96m     "3rd line"[m
[96m];[m
[96mconsole.log(arr.join("\n"));[m
[96m^C[m
[96m$ node multilineES5_array.js[m
[96m1st line[m
[96m2nd line[m
[96m3rd line[m


   MMuullttiilliinnee SSttrriinnggss tthhee EEaassyy WWaayy
[96m$ cat > multilineString.js[m
[96mlet text1 = `1st line[m
[96m2nd line`;[m
[96m[m
[96mlet text2 = `3rd line[m
[96m             4th line`;[m
[96m[m
[96mlet text3 = `5th line\n6th line`;[m
[96m[m
[96mconsole.log(text1);[m
[96mconsole.log(text1.length);[m
[96m[m
[96mconsole.log(text2);[m
[96mconsole.log(text2.length);[m
[96m[m
[96mconsole.log(text3);[m
[96mconsole.log(text3.length);[m
[96m^C[m
[96m$ node multilineString.js[m
[96m1st line[m
[96m2nd line[m
[96m17[m
[96m3rd line[m
[96m             4th line[m
[96m30[m
[96m5th line[m
[96m6th line[m
[96m17[m


       Whitespace  characters are part of the strings, so mind indentation. '\n'
       can be used inside template literals.

   MMaakkiinngg SSuubbssttiittuuttiioonnss
       Substitutions are delimited by an opening '${' and a closing '}' that can
       have any JS expression inside:

[96m$ cat > substitution.js[m
[96mlet name = "Nicholas",[m
[96m    message = `Hello, ${name}.`;[m
[96m[m
[96mconsole.log(message);[m
[96m^C[m
[96m$ node substitution.js[m
[96mHello, Nicholas.[m


       In  the  example  above,  the  'message' variable holds the result of the
       substitution immediately.

              [page 28] "A template literal can access any  variable  accessible
              in  the  scope  in  which  it  is  defined.  Attempting  to use an
              undeclared variable in a  template  literal  throws  an  error  in
              strict and non-strict modes" [page 28]

       Substitutions can be any JS expressions. Since template literals are also
       JS expressions they can be used in substitution:

[96m$ cat > substitutions.js[m
[96mlet count = 10,[m
[96m    price = 0.25,[m
[96m    message = `${count} items cost $${(count * price).toFixed(2)}.`;[m
[96m[m
[96mconsole.log(message);[m
[96m[m
[96mlet name = "Nicholas",[m
[96m    greeting =[m
[96m        `Hello, ${[m
[96m            `my name is ${ name }`[m
[96m        }.`;[m
[96m[m
[96mconsole.log(greeting);[m
[96m^C[m
[96m$ node substitutions.js[m
[96m10 items cost $2.50.[m
[96mHello, my name is Nicholas.[m


   TTaaggggeedd TTeemmppllaatteess
       A template tag preforms a transformation  on  the  template  literal  and
       returns the final string value.

   DDeeffiinniinngg TTaaggss
       A  tag  is  simply  a function that is called with the processed template
       literal data. The 1st argument is an array containing the literal strings
       as  interpreted by JS. Each subsequest argumetnt is the interpreted value
       of each substitution.

[96m$ cat > tag.js[m
[96mfunction myTag(literals, ...substitutions) {[m
[96m     console.log('literals:');[m
[96m     literals.forEach([m
[96m          function(literal) { console.log(literal); }[m
[96m     );[m
[96m     console.log('substitutions:');[m
[96m     substitutions.forEach([m
[96m          function(substitution) { console.log(substitution); }[m
[96m     );[m
[96m}[m
[96m[m
[96mlet count = 10,[m
[96m    price = 0.25,[m
[96m    message = myTag`${count} items cost $${(count * price).toFixed(2)}.`;[m
[96m^C[m
[96m$ node tag.js[m
[96mliterals:[m
[96m[m
[96m items cost $[m
[96msubstitutions:[m
[96m10[m
[96m2.50[m


       From the exmple above we can see that the 'literals' array consistst of 3
       parts:  an  empty  string  before  the 1st substitution, the part between
       substitutions and the '.' string after the last substitution. The  number
       of substitutions will always be one fewer than that of literals.

              [page  31]  "The  values  contained  in  'substitutions'  are  not
              necessarily strings. If an expression evaluates to a number, as in
              the  previous example, the numeric value is passed in. Determining
              how such values should output in the result is part of  the  tag's
              job." [page 31]

   UUssiinngg RRaaww VVaalluueess iinn TTeemmppllaattee LLiitteerraallss
       Template tags also have access to raw string information, which primarily
       means access to character escapes before they're transformed  into  their
       character  equivalents. The simplest way to work with raw string value is
       to use the built-in String.raw() tag:

[96m$ cat > raw.js[m
[96mlet text = "Multiline\nstring";[m
[96mconsole.log(text);[m
[96mconsole.log(String.raw`${text}`);[m
[96mconsole.log(String.raw`1st line\n2nd line`);[m
[96m^C[m
[96m$ node raw.js[m
[96mMultiline[m
[96mstring[m
[96mMultiline[m
[96mstring[m
[96m1st line\n2nd line[m


       The raw string information is also passed into  template  tags.  The  1st
       fragment  in  a  tag  function  is an array with an extra property called
       'raw'. It is an array containing  the  raw  equivalent  of  each  literal
       value.

[96m$ cat > rawTag.js[m
[96mfunction raw(literals, ...substitutions) {[m
[96m     let result = '';[m
[96m     for (let i = 0; i < substitutions.length; ++i) {[m
[96m          result += literals.raw[i];[m
[96m          result += substitutions[i];[m
[96m     }[m
[96m     result += literals.raw[literals.length - 1];[m
[96m     return result;[m
[96m};[m
[96m[m
[96mlet message = raw`Multiline\nstring`;[m
[96m[m
[96mconsole.log(message);[m
[96mconsole.log(message.length);[m
[96m[m
[96mconsole.log('Multiline\\nstring');[m
[96mconsole.log('Multiline\\nstring'.length);[m
[96m^C[m
[96m$ node rawTag.js[m
[96mMultiline\nstring[m
[96m17[m
[96mMultiline\nstring[m
[96m17[m


toolsV1                                                 yet_another_webdev(blog)
